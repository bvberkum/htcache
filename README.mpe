:project: http://freshmeat.net/projects/http-replicator
:bzr-branch: http://launchpad.net/~mpe/+junk/http-replicator.mpe

Based on the http-replicator_4.0alpha2 branch found on the web.
Rename fork and start at 0.1, see todo 4.

Changes in functionality to http-replicator:
 - Ignore host/path based on RegEx patterns read from file. Each line is a
   complete pattern, matched against request URI. Offending pattern is logged, 
   and response switched to static placeholder.
 - Created Sys-V init sh script, init.sh.
   cp/rename it to /etc/init.d/ and make appropiate symlinks. Edit it to reflect
   systems locations. Also see http://www.debian-administration.org/articles/28
   for Debian specifics.
 - Including HTTP Via header in requests to origin server.
 - Keeping of descriptors for each cached file in 'flat' DB.
 - Alternative cache directory layouts.

Todo
 1. Writing to client fails randomly, probably malformed headers?
 2. Some date headers fail to parse.
 3. There is a version with other cl-options, it uses stdlib asyncore
    check: 
 
     * http://web.archive.org/web/20070816213819/gertjan.freezope.org/replicator/http-replicator
     * http://web.archive.org/web/20071214200800/gertjan.freezope.org/replicator
  
 4. Make release? add this to RELNOTES/CHANGELOG, update and reorganize manual..
 5. init.sh script is too fragile, script should daemonize itself.

Issues
 1. HTML placeholder served for all connections (e.g. also for flash, images)

Installation
------------
Start as any Python script, or:

- cp/link http-replicator into ``/usr/bin`` 
- cp/link ``init.sh`` into ``/dev/init.d/``, modify http-replicator flags as needed.
  Make sure paths in init.sh and Params.py are accessible.
- add line ``/etc/init.d/http-replicator start`` to ``/etc/local`` for 
  on-startup initialization.

Also create files in /etc/http-replicator:

* rules.drop
* rules.nocache 
* rewrite.request
* rewrite.response
* rewrite.always


Overview
--------
http-replicator client/server flow::

   .                         htcache 
                             _______
                                o <------------*request---  client
                                |
                                |---blocked response(1)--->
                                |---static response(7)---->
   server <------------normal---|
          <------*conditional---' 
           --*normal------------o
                                |--*normal----------------> 
                                `--*nocache response(4)---> 
           ---not modified----> o--*cached response------->       
           ---error-----------> o---direct response------->       

.. planned implementation

   .                         htcache 
                             _______
                                o <---*request------------  client
                                |
                                |---blocked response(1)--->
                                |---static response(7)---->
   server <-----------*normal---|
          <-*rewritten(2)---'   |   
          <------*conditional---' 
          <-*rewritten(2)---'       
           -*normal-------------. 
             |                  v
             `-*rewritten(3)--> o 
                                |--*normal response-------> 
                                |   |
                                |--*sorted response(5)----> 
                                |   |
                                `--*noncached response(4)-> 
                                    |
           --not modified-----> o--*cached response------->       
                                    |
                                    `*filtered response(6)>
           --error------------> o---blind response-------->       


The asterix indicates wether there may be partial entity-content transfer. 

Normally a request creates a new cache location and descriptor, static 
responses are always served from cache and conditional requests may be.

Beside these messages, also note the following special cases of request 
and response messages.

1. blocked response                                  (rules.drop)
2. TODO: rewritten request                           (rewrite.request)
3. TODO: rewritten response (cache modified message) (rewrite.beforecache)
4. blind response (uncached content)                 (rules.nocache)
5. TODO: alternative cache location                  (rules.sort)
6. TODO: rewritten response after caching            (rewrite.aftercache)

All these cases are matched based on the following parts of a message:

- host, port, path, URL, request-line, headers[, content]; for request, and
- status, code, response-line, headers[, content]; for response.

.. admonition:: XXX

   with current implementation, only (a part) of the URL is considered
   during filtering.

See _`Filter <Filter rules>` and _`Rewrite rules` for the exact syntax.

Configuration
~~~~~~~~~~~~~
There is no separate configuration file, see Params.py and init.sh for 
option arguments to the program, and for their default settings. Other settings
are given in the rewrite and rules files described above.

The programs options are divided in three parts, the first group affects 
the proxy server, which default action.

To manage the cached resources and their descriptors, additional
query and maintenance options are provided. Note that maintenance may need
exclusive write access to the cache and descriptor backends, meaning it should
not run while the proxy is running. 

Cache backends
~~~~~~~~~~~~~~
htcache uses a file-based Cache which may produce a file-tree similar to 
that of ``wget -r``. This could create some problems with long filenames and 
the characters that appear in HTTP query parts.

Additional backends are provided addressing mentioned problem.
(default: Cache.File, ``--cache TYPE``):

- caches.FileTreeQ - wget and HR fail on long filenames, usually caused by long
  query parts. FileTreeQ encodes each query argument into a separate directory,
  the first argument being prefixed with '?'.
- caches.FileTreeQH - Converts query into a hashsum. This one makes a bit more
  sense because queries are not hierarchical. The hashsum is encoded to a
  directory, the name prefixed with '#'.

- caches.RefHash - simply encodes full URI into MD5 hex-digest and use as
  filename.

- caches.HTContentStore - TODO: a content-hash index in dba2 api compat

The storage location is futher affected by ``--archive`` and ``--nodir``.

Regular archival of a resources is possible by prefixing a formatted date to
the path. Ie. '%Y/%M/%d' would store a copy and maintain updates of a 
resource for every day. Prefixing a timestamp would store a new copy for each
request.

The nodir parameter accepts a replacement for the directory separator and
stores the path in a single filename. This may affect FileTreeQ.

Descriptor backends
~~~~~~~~~~~~~~~~~~~
The descriptor backend (which contains URI, mediatype, charset, language and
other resource-header data) is by default stored in a flat index DB. No
additional backends available at this time.

TODO: a file-based header storage or perhaps even an Apache mod_asis
compatible storage are under consideration. Depending on query/maintenance
requirements.

Filter rules
~~~~~~~~~~~~
Requests and responses may be filtered based on request URL, method, headers or content.
Rules are provided in rules.drop and rules.nocache.

The former causes a placeholder to be served instead of the origin server
content, the latter bypasses caching.

XXX: lines are expressions, empty or start with #
TODO: multi-item rules, use python for list syntax

Rewrite rules
~~~~~~~~~~~~~
TODO: Requests and responses may have their various parts rewritten.

