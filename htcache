#! /usr/bin/env python
import os
import sys
import time
import weakref
import traceback


# XXX: development tooling:
try:
    import coverage
    coverage.process_startup()
except ImportError, e:
    pass


import fiber
import Params, Runtime, Command
import Cache
import Protocol, Request, Response
import Resource
import Rules
from util import get_log




DOWNLOADS = Runtime.DOWNLOADS = weakref.WeakValueDictionary()
"""
Global set of download sessions, each being a request, protocol mapping.

Only one download per resource is needed, just the first request is kept here.
Each subsequent session will cannot overwrite the file, but can "join" the download
by switching to the response fase.

XXX: This also allows local lookup of resources, ie. to rewrite the cache location
to locally stored data.
"""

def HTCache_fiber_handler( client, address ):

#    import sys
#    print 'PID', sys.getpid()
#    print 'PPID', sys.getppid()

    get_log(Params.LOG_DEBUG)\
            ("Log level is at %s", Runtime.VERBOSE)

    protocol = None
    request = Request.HtRequest()
    get_log(Params.LOG_DEBUG)\
            ('%s: New Request from %r, downloads: %s; +1', 
                    hex(id(request)), address, len(DOWNLOADS))

    while not request.Protocol:
        get_log(Params.LOG_DEBUG)\
                ('%s: Reading request', hex(id(request)))
        yield fiber.RECV( client, Params.TIMEOUT )
        request.recv( client )

    try:
        while request in DOWNLOADS:
            # Already downloading
            protocol = DOWNLOADS[ request ]
            if protocol.Response:
                if issubclass( protocol.Response, Response.DataResponse ):
                    get_log(Params.LOG_DEBUG)\
                            ('Checking with %r for data for %r ' % (protocol.data, request))
                    while not protocol.data.exists():
                        get_log(Params.LOG_INFO)\
                                ('Waiting to join downloads for %r' % request)
                        yield fiber.WAIT()
                        # XXX: wait till data has finished and closed, then
                        # re-use it for this download???
                        if not protocol.data.descriptor:
                            protocol.data.prepare_static()
                    else:
                        get_log(Params.LOG_INFO)\
                                ('Joining running download, re-using protocol')
                        break
#                del DOWNLOADS[ request ]
            else:
                yield fiber.WAIT()
        else:
            get_log(Params.LOG_INFO)\
                    ('Switching to %s', request.Protocol.__name__)
            protocol = DOWNLOADS[ request ] = request.Protocol( request )
            get_log(Params.LOG_DEBUG)\
                    ('%s: New %s for %s', hex(id(protocol)),
                            request.Protocol.__name__, hex(id(request)))

            if not protocol.Response:
                server = protocol.socket()

            while not protocol.Response:
                if protocol.hasdata():
                    get_log(Params.LOG_DEBUG)\
                            ('%s: Reading response for %s', hex(id(protocol)), hex(id(request)))
                    yield fiber.SEND( server, Params.TIMEOUT )
                    protocol.send( server )
                else:
                    yield fiber.RECV( server, Params.TIMEOUT )
                    protocol.recv( server )

        get_log(Params.LOG_NOTE)\
                ('Switching to %s', protocol.Response.__name__)
        response = protocol.Response( protocol, request )
        get_log(Params.LOG_DEBUG)\
                ('%s: New %s for %s', hex(id(response)),
                        protocol.Response.__name__, hex(id(request)))
        server = protocol.socket()

    except Exception, e:
        get_log(Params.LOG_CRIT)\
                ('Warning: Switching to ExceptionResponse, reason: %s', e)
        response = Response.ExceptionResponse( protocol, request )

    # blocks while client has not read data
    while not response.Done:
        if response.hasdata():
            get_log(Params.LOG_DEBUG)\
                    ('%s: Writing response for %s', hex(id(response)), hex(id(request)))
            yield fiber.SEND( client, Params.TIMEOUT )
            response.send( client )
        elif response.needwait():
            yield fiber.WAIT( response.needwait() )
        else:
            yield fiber.RECV( server, Params.TIMEOUT )
            response.recv( server )

    get_log(Params.LOG_NOTE)('Transaction completed for %r with data %s', 
            hex(id(request)), hex(id(protocol.data)))

    assert protocol

    response.finalize(client)

    if request in DOWNLOADS:
        del DOWNLOADS[request]


def run():
    get_log(Params.LOG_DEBUG)("ARGV: %r", sys.argv)

    try:

        Command.CLIParams().parse()

    except Exception:
        traceback.print_exc()
        print >>sys.stderr, "Failure during initalization"


    ### Cache Maintenance static entry

    try:

        if Command.run():
            if Command.exceptions:
                if Runtime.DEBUG:
                    print
                    print "Detailed error reports: "
                    for tp, exc, tb in Command.exceptions:
                        traceback.print_exception(tp, exc, tb)
                sys.exit(1)
            else:
                sys.exit(0)

    except Exception:
        # XXX: programming catch
        traceback.print_exc()
        print >>sys.stderr, "Error running commands"


    ### Normal proxy subroutine

    while True:
        try:
            fiber.spawn(
                    HTCache_fiber_handler,
                    Runtime.HOSTNAME,
                    Runtime.PORT,
                    Runtime.DEBUG,
                    Runtime.LOG,
                    Runtime.PID_FILE )

        except fiber.Restart, e:
            Resource.SessionMixin.close_instance('default')
            for mod in ( Params, Runtime, Command, Protocol, Request, Response, Resource, fiber):
                mod = reload(mod)

        except Exception, e:
            traceback.print_exc()
            sys.exit(1)
            break


if __name__ == '__main__':


    run()


